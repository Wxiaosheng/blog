## JavaScript 的执行

### 宏观和微观任务
JavaScript 语言，采纳 JSC 引擎的术语，我们把宿主发起的任务称为**宏观任务**，把 JavaScript 引擎发起的任务称为**微观任务**

JavaScript 引擎等待宿主环境分配宏观任务，宏观任务的队列可以理解为一个事件循环，每个宏观任务中又包含一个微观任务队列  
* setTimeout等宿主API，会添加宏观任务  
* Promise永远在队列尾部添加微观任务

### Promise
Promise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 **Promise 的 then 方法的回调**）

### 异步执行的顺序
* 首先分析有多少个宏任务
* 在每个宏任务中，分析有多少个微任务
* 根据调用次序，确定宏任务中微任务执行次序
* 根据宏任务的触发规则和调用次序，确定宏任务执行次序
* 确定整个次序

### 闭包 - closure
> 其实是一个绑定了执行环境的函数
在计算机领域，它就有三个完全不相同的意义：
* 编译原理中，它是处理语法产生式的一个步骤；
* 计算几何中，它表示包裹平面点集的凸多边形（翻译作凸包）；
* 在编程语言领域，它表示一种函数。

#### 定义
古典的闭包定义中，闭包包含两个部分：
* 环境部分
  * 环境
  * 标识符列表
* 表达式部分

实际上 JavaScript 中跟闭包对应的概念就是“函数”，它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。

### 执行上下文
> 执行的基础设施
在 ES2018中，执行上下文包括一下7个部分：
* lexical environment: 词法环境，获取变量或 this 值使用
* variable enviroment：变量环境，当声明变量时使用
* code evaluation state: 用于恢复代码执行位置
* Function：执行的任务是函数，表示正在被执行的函数
* ScriptOrMode：执行的任务是脚本或模块时使用，表示正在执行的代码
* Realm：使用的基础库和内置对象实例
* Generator：仅生成器上下文才有，表示当前生成器

#### var 声明与赋值
**var 声明作用域函数执行的作用域**，这意味着 var 会穿透 for、if 等语句

!> 在没有 let、const 的情况下，使用 **立即执行的函数表达式(IIFE)**，来构造一个新域，控制 var 的范围，推荐 void 的写法
```javascript
;(function (){
  var a ;
  // code
})()

// 推荐写法，语义上 void 运算表示忽略后面表达式的值，变成 undefined
void (function () {
  var b;
  // code
})()
```

### Realm
在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是“国度”“领域”“范围”。  
Realm 中包含一组完整的内置对象，而且是复制关系。对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的


### 函数
在 JavaScript，切换上下文最主要的场景是函数调用。

#### 种类
1. 普通函数
2. 箭头函数
3. 方法（在 class 中定义的函数）
4. 生成器函数 （用 function * 定义的函数）
5. 用 class 定义的类 （本质上也是函数）
6. 异步函数（普通函数、箭头函数 和 生成器 函数 加上 async 关键字）

#### this 关键字的行为


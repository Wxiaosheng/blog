### 块级作用域：var缺陷以及为什么要引入let和const？

#### 作用域
**作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期**  
**通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期** 

* **全局作用域** 中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期
* **函数作用域** 就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁
* **块级作用域(ES6后才有)** 就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域

#### 探病因
> 分析为什么在 JavaScript 中会存在变量提升，以及变量提升所带来的问题

ES6 之前是不支持块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升

##### 变量提升所带来的问题
1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁

#### 开药方
> 介绍如何通过块级作用域并配合 let 和 const 关键字来修复这种缺陷

ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域

##### JavaScript 是如何支持块级作用域的
* 第一步是编译并创建执行上下文
  * 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了
  * 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中
  * 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中
* 执行代码块中代码
  * 作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量

![block space](https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png)


### 总结
JavaScript 的变量提升存在着变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题